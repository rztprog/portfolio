import t from"crypto";import e from"figgy-pudding";import r from"stream";import i from"buffer";var s={};var n=i.Buffer;const o=t;const a=e;const c=r.Transform;const h=["sha256","sha384","sha512"];const g=/^[a-z0-9+/]+(?:=?=?)$/i;const m=/^([^-]+)-([^?]+)([?\S*]*)$/;const f=/^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)?$/;const u=/^[\x21-\x7E]+$/;const l=a({algorithms:{default:["sha512"]},error:{default:false},integrity:{},options:{default:[]},pickAlgorithm:{default:()=>getPrioritizedHash},Promise:{default:()=>Promise},sep:{default:" "},single:{default:false},size:{},strict:{default:false}});class Hash{get isHash(){return true}constructor(t,e){e=l(e);const r=!!e.strict;this.source=t.trim();const i=this.source.match(r?f:m);if(!i)return;if(r&&!h.some((t=>t===i[1])))return;this.algorithm=i[1];this.digest=i[2];const s=i[3];this.options=s?s.slice(1).split("?"):[]}hexDigest(){return this.digest&&n.from(this.digest,"base64").toString("hex")}toJSON(){return this.toString()}toString(t){t=l(t);if(t.strict&&!(h.some((t=>t===this.algorithm))&&this.digest.match(g)&&(this.options||[]).every((t=>t.match(u)))))return"";const e=this.options&&this.options.length?`?${this.options.join("?")}`:"";return`${this.algorithm}-${this.digest}${e}`}}class Integrity{get isIntegrity(){return true}toJSON(){return this.toString()}toString(t){t=l(t);let e=t.sep||" ";t.strict&&(e=e.replace(/\S+/g," "));return Object.keys(this).map((r=>this[r].map((e=>Hash.prototype.toString.call(e,t))).filter((t=>t.length)).join(e))).filter((t=>t.length)).join(e)}concat(t,e){e=l(e);const r="string"===typeof t?t:stringify(t,e);return parse(`${this.toString(e)} ${r}`,e)}hexDigest(){return parse(this,{single:true}).hexDigest()}match(t,e){e=l(e);const r=parse(t,e);const i=r.pickAlgorithm(e);return this[i]&&r[i]&&this[i].find((t=>r[i].find((e=>t.digest===e.digest))))||false}pickAlgorithm(t){t=l(t);const e=t.pickAlgorithm;const r=Object.keys(this);if(!r.length)throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);return r.reduce(((t,r)=>e(t,r)||t))}}s.parse=parse;function parse(t,e){e=l(e);if("string"===typeof t)return _parse(t,e);if(t.algorithm&&t.digest){const r=new Integrity;r[t.algorithm]=[t];return _parse(stringify(r,e),e)}return _parse(stringify(t,e),e)}function _parse(t,e){return e.single?new Hash(t,e):t.trim().split(/\s+/).reduce(((t,r)=>{const i=new Hash(r,e);if(i.algorithm&&i.digest){const e=i.algorithm;t[e]||(t[e]=[]);t[e].push(i)}return t}),new Integrity)}s.stringify=stringify;function stringify(t,e){e=l(e);return t.algorithm&&t.digest?Hash.prototype.toString.call(t,e):"string"===typeof t?stringify(parse(t,e),e):Integrity.prototype.toString.call(t,e)}s.fromHex=fromHex;function fromHex(t,e,r){r=l(r);const i=r.options&&r.options.length?`?${r.options.join("?")}`:"";return parse(`${e}-${n.from(t,"hex").toString("base64")}${i}`,r)}s.fromData=fromData;function fromData(t,e){e=l(e);const r=e.algorithms;const i=e.options&&e.options.length?`?${e.options.join("?")}`:"";return r.reduce(((r,s)=>{const n=o.createHash(s).update(t).digest("base64");const a=new Hash(`${s}-${n}${i}`,e);if(a.algorithm&&a.digest){const t=a.algorithm;r[t]||(r[t]=[]);r[t].push(a)}return r}),new Integrity)}s.fromStream=fromStream;function fromStream(t,e){e=l(e);const r=e.Promise||Promise;const i=integrityStream(e);return new r(((e,r)=>{t.pipe(i);t.on("error",r);i.on("error",r);let s;i.on("integrity",(t=>{s=t}));i.on("end",(()=>e(s)));i.on("data",(()=>{}))}))}s.checkData=checkData;function checkData(t,e,r){r=l(r);e=parse(e,r);if(!Object.keys(e).length){if(r.error)throw Object.assign(new Error("No valid integrity hashes to check against"),{code:"EINTEGRITY"});return false}const i=e.pickAlgorithm(r);const s=o.createHash(i).update(t).digest("base64");const n=parse({algorithm:i,digest:s});const a=n.match(e,r);if(a||!r.error)return a;if("number"===typeof r.size&&t.length!==r.size){const i=new Error(`data size mismatch when checking ${e}.\n  Wanted: ${r.size}\n  Found: ${t.length}`);i.code="EBADSIZE";i.found=t.length;i.expected=r.size;i.sri=e;throw i}{const r=new Error(`Integrity checksum failed when using ${i}: Wanted ${e}, but got ${n}. (${t.length} bytes)`);r.code="EINTEGRITY";r.found=n;r.expected=e;r.algorithm=i;r.sri=e;throw r}}s.checkStream=checkStream;function checkStream(t,e,r){r=l(r);const i=r.Promise||Promise;const s=integrityStream(r.concat({integrity:e}));return new i(((e,r)=>{t.pipe(s);t.on("error",r);s.on("error",r);let i;s.on("verified",(t=>{i=t}));s.on("end",(()=>e(i)));s.on("data",(()=>{}))}))}s.integrityStream=integrityStream;function integrityStream(t){t=l(t);const e=t.integrity&&parse(t.integrity,t);const r=e&&Object.keys(e).length;const i=r&&e.pickAlgorithm(t);const s=r&&e[i];const n=Array.from(new Set(t.algorithms.concat(i?[i]:[])));const a=n.map(o.createHash);let h=0;const g=new c({transform(t,e,r){h+=t.length;a.forEach((r=>r.update(t,e)));r(null,t,e)}}).on("end",(()=>{const o=t.options&&t.options.length?`?${t.options.join("?")}`:"";const c=parse(a.map(((t,e)=>`${n[e]}-${t.digest("base64")}${o}`)).join(" "),t);const m=r&&c.match(e,t);if("number"===typeof t.size&&h!==t.size){const r=new Error(`stream size mismatch when checking ${e}.\n  Wanted: ${t.size}\n  Found: ${h}`);r.code="EBADSIZE";r.found=h;r.expected=t.size;r.sri=e;g.emit("error",r)}else if(t.integrity&&!m){const t=new Error(`${e} integrity checksum failed when using ${i}: wanted ${s} but got ${c}. (${h} bytes)`);t.code="EINTEGRITY";t.found=c;t.expected=s;t.algorithm=i;t.sri=e;g.emit("error",t)}else{g.emit("size",h);g.emit("integrity",c);m&&g.emit("verified",m)}}));return g}s.create=createIntegrity;function createIntegrity(t){t=l(t);const e=t.algorithms;const r=t.options.length?`?${t.options.join("?")}`:"";const i=e.map(o.createHash);return{update:function(t,e){i.forEach((r=>r.update(t,e)));return this},digest:function(s){const n=e.reduce(((e,s)=>{const n=i.shift().digest("base64");const o=new Hash(`${s}-${n}${r}`,t);if(o.algorithm&&o.digest){const t=o.algorithm;e[t]||(e[t]=[]);e[t].push(o)}return e}),new Integrity);return n}}}const p=new Set(o.getHashes());const d=["md5","whirlpool","sha1","sha224","sha256","sha384","sha512","sha3","sha3-256","sha3-384","sha3-512","sha3_256","sha3_384","sha3_512"].filter((t=>p.has(t)));function getPrioritizedHash(t,e){return d.indexOf(t.toLowerCase())>=d.indexOf(e.toLowerCase())?t:e}const y=s.create;const $=s.parse,S=s.stringify,w=s.fromHex,k=s.fromData,x=s.fromStream,E=s.checkData,H=s.checkStream,b=s.integrityStream;export default s;export{E as checkData,H as checkStream,y as create,k as fromData,w as fromHex,x as fromStream,b as integrityStream,$ as parse,S as stringify};

