import"util";import o from"./Hook.js";import e from"./HookCodeFactory.js";import r from"./SyncBailHook.js";import t from"./Tapable.js";import n from"./SyncHook.js";import s from"./AsyncParallelHook.js";import a from"./AsyncSeriesHook.js";import l from"./AsyncSeriesBailHook.js";import i from"./HookMap.js";var c={};const u=o;const p=e;class SyncWaterfallHookCodeFactory extends p{content({onError:o,onResult:e,resultReturns:r,rethrowIfPossible:t}){return this.callTapsSeries({onError:(e,r)=>o(r),onResult:(o,e,r)=>{let t="";t+=`if(${e} !== undefined) {\n`;t+=`${this._args[0]} = ${e};\n`;t+=`}\n`;t+=r();return t},onDone:()=>e(this._args[0]),doneReturns:r,rethrowIfPossible:t})}}const k=new SyncWaterfallHookCodeFactory;class SyncWaterfallHook extends u{constructor(o){super(o);if(o.length<1)throw new Error("Waterfall hooks must have at least one argument")}tapAsync(){throw new Error("tapAsync is not supported on a SyncWaterfallHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncWaterfallHook")}compile(o){k.setup(this,o);return k.create(o)}}c=SyncWaterfallHook;var f=c;var y={};const H=o;const h=e;class SyncLoopHookCodeFactory extends h{content({onError:o,onDone:e,rethrowIfPossible:r}){return this.callTapsLooping({onError:(e,r)=>o(r),onDone:e,rethrowIfPossible:r})}}const d=new SyncLoopHookCodeFactory;class SyncLoopHook extends H{tapAsync(){throw new Error("tapAsync is not supported on a SyncLoopHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncLoopHook")}compile(o){d.setup(this,o);return d.create(o)}}y=SyncLoopHook;var m=y;var S={};const A=o;const w=e;class AsyncParallelBailHookCodeFactory extends w{content({onError:o,onResult:e,onDone:r}){let t="";t+=`var _results = new Array(${this.options.taps.length});\n`;t+="var _checkDone = () => {\n";t+="for(var i = 0; i < _results.length; i++) {\n";t+="var item = _results[i];\n";t+="if(item === undefined) return false;\n";t+="if(item.result !== undefined) {\n";t+=e("item.result");t+="return true;\n";t+="}\n";t+="if(item.error) {\n";t+=o("item.error");t+="return true;\n";t+="}\n";t+="}\n";t+="return false;\n";t+="}\n";t+=this.callTapsParallel({onError:(o,e,r,t)=>{let n="";n+=`if(${o} < _results.length && ((_results.length = ${o+1}), (_results[${o}] = { error: ${e} }), _checkDone())) {\n`;n+=t(true);n+="} else {\n";n+=r();n+="}\n";return n},onResult:(o,e,r,t)=>{let n="";n+=`if(${o} < _results.length && (${e} !== undefined && (_results.length = ${o+1}), (_results[${o}] = { result: ${e} }), _checkDone())) {\n`;n+=t(true);n+="} else {\n";n+=r();n+="}\n";return n},onTap:(o,e,r,t)=>{let n="";if(o>0){n+=`if(${o} >= _results.length) {\n`;n+=r();n+="} else {\n"}n+=e();o>0&&(n+="}\n");return n},onDone:r});return t}}const P=new AsyncParallelBailHookCodeFactory;class AsyncParallelBailHook extends A{compile(o){P.setup(this,o);return P.create(o)}}Object.defineProperties(AsyncParallelBailHook.prototype,{_call:{value:void 0,configurable:true,writable:true}});S=AsyncParallelBailHook;var _=S;var v={};const W=o;const g=e;class AsyncSeriesWaterfallHookCodeFactory extends g{content({onError:o,onResult:e,onDone:r}){return this.callTapsSeries({onError:(e,r,t,n)=>o(r)+n(true),onResult:(o,e,r)=>{let t="";t+=`if(${e} !== undefined) {\n`;t+=`${this._args[0]} = ${e};\n`;t+=`}\n`;t+=r();return t},onDone:()=>e(this._args[0])})}}const $=new AsyncSeriesWaterfallHookCodeFactory;class AsyncSeriesWaterfallHook extends W{constructor(o){super(o);if(o.length<1)throw new Error("Waterfall hooks must have at least one argument")}compile(o){$.setup(this,o);return $.create(o)}}Object.defineProperties(AsyncSeriesWaterfallHook.prototype,{_call:{value:void 0,configurable:true,writable:true}});v=AsyncSeriesWaterfallHook;var B=v;var E={};const b=o;class MultiHook{constructor(o){this.hooks=o}tap(o,e){for(const r of this.hooks)r.tap(o,e)}tapAsync(o,e){for(const r of this.hooks)r.tapAsync(o,e)}tapPromise(o,e){for(const r of this.hooks)r.tapPromise(o,e)}isUsed(){for(const o of this.hooks)if(o.isUsed())return true;return false}intercept(o){for(const e of this.hooks)e.intercept(o)}withOptions(o){return new MultiHook(this.hooks.map(e=>e.withOptions(o)))}}E=MultiHook;var j=E;var M={};M.__esModule=true;M.Tapable=t;M.SyncHook=n;M.SyncBailHook=r;M.SyncWaterfallHook=f;M.SyncLoopHook=m;M.AsyncParallelHook=s;M.AsyncParallelBailHook=_;M.AsyncSeriesHook=a;M.AsyncSeriesBailHook=l;M.AsyncSeriesWaterfallHook=B;M.HookMap=i;M.MultiHook=j;const x=M.__esModule,D=M.Tapable,L=M.SyncHook,C=M.SyncBailHook,F=M.SyncWaterfallHook,R=M.SyncLoopHook,T=M.AsyncParallelHook,I=M.AsyncParallelBailHook,O=M.AsyncSeriesHook,U=M.AsyncSeriesBailHook,q=M.AsyncSeriesWaterfallHook,z=M.HookMap,G=M.MultiHook;export default M;export{I as AsyncParallelBailHook,T as AsyncParallelHook,U as AsyncSeriesBailHook,O as AsyncSeriesHook,q as AsyncSeriesWaterfallHook,z as HookMap,G as MultiHook,C as SyncBailHook,L as SyncHook,R as SyncLoopHook,F as SyncWaterfallHook,D as Tapable,x as __esModule};

