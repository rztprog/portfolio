import r from"fs";import t from"path";import e from"pify";import o from"semver";import s from"process";var n={};var c=s;const i=r;const m=t;const a=e;const d=o;const f={mode:511&~c.umask(),fs:i};const h=d.satisfies(c.version,">=10.12.0");const checkPath=r=>{if("win32"===c.platform){const t=/[<>:"|?*]/.test(r.replace(m.parse(r).root,""));if(t){const t=new Error(`Path contains invalid characters: ${r}`);t.code="EINVAL";throw t}}};const permissionError=r=>{const t=new Error(`operation not permitted, mkdir '${r}'`);t.code="EPERM";t.errno=-4048;t.path=r;t.syscall="mkdir";return t};const makeDir=(r,t)=>Promise.resolve().then(()=>{checkPath(r);t=Object.assign({},f,t);const e=a(t.fs.mkdir);const o=a(t.fs.stat);if(h&&t.fs.mkdir===i.mkdir){const o=m.resolve(r);return e(o,{mode:t.mode,recursive:true}).then(()=>o)}const make=r=>e(r,t.mode).then(()=>r).catch(t=>{if("EPERM"===t.code)throw t;if("ENOENT"===t.code){if(m.dirname(r)===r)throw permissionError(r);if(t.message.includes("null bytes"))throw t;return make(m.dirname(r)).then(()=>make(r))}return o(r).then(t=>t.isDirectory()?r:Promise.reject()).catch(()=>{throw t})});return make(m.resolve(r))});n=makeDir;n.default=makeDir;n.sync=(r,t)=>{checkPath(r);t=Object.assign({},f,t);if(h&&t.fs.mkdirSync===i.mkdirSync){const e=m.resolve(r);i.mkdirSync(e,{mode:t.mode,recursive:true});return e}const make=r=>{try{t.fs.mkdirSync(r,t.mode)}catch(e){if("EPERM"===e.code)throw e;if("ENOENT"===e.code){if(m.dirname(r)===r)throw permissionError(r);if(e.message.includes("null bytes"))throw e;make(m.dirname(r));return make(r)}try{if(!t.fs.statSync(r).isDirectory())throw new Error("The path is not a directory")}catch(r){throw e}}return r};return make(m.resolve(r))};var u=n;const l=n.sync;export default u;export{l as sync};

